/*
* Definition of grammar rules for production and also
* terminal and non terminal symbols for the Pascal.
*/
                
terminal  BEGIN, CASE, CONST;
terminal  String AND, NOT, OR, MINUS, STAR, PLUS;
terminal  String DIV, MOD, SLASH;
terminal  DO, DOWNTO, ELSE, END, FILE, FOR, FORWARD, FUNCTION;
terminal  IMPLEMENTATION, IN, INTERFACE, LABEL, NIL;
terminal  OF, PACKED, PROCEDURE, PROGRAM, RECORD, SET, EXTERNAL;
terminal  STRING, THEN, TO, TYPE, UNIT, USES, VAR, WITH, XOR;
terminal  SEMICOLON, DOT;
terminal  String IDENTIFIER, CHARACTER_STRING;
terminal  ASSIGNMENT;
terminal  COLON, COMMA, DIGSEQ;
terminal  DOTDOT, EQUAL;
terminal  GE, GT, LBRAC, LE, LPAREN, LT;
terminal  NOTEQUAL, PBEGIN, PFILE, RBRAC;
terminal  REALNUMBER, RPAREN, STARSTAR, UPARROW;
terminal  INTEGER, BOOLEAN, REAL, CHAR, TRUE, FALSE;

non terminal program, program_heading;
non terminal List<String> identifier_list;
non terminal block, module;
non terminal label_declaration_part, label_list, label, constant_definition_part;
non terminal constant_list, constant_definition;
non terminal Tipo cexpression, csimple_expression;
non terminal Tipo cterm, cfactor, cexponentiation, cprimary, constant, non_string;
non terminal type_definition_part, type_definition_list, type_definition;
non terminal Tipo type_denoter, result_type;
non terminal new_type, new_ordinal_type, enumerated_type, subrange_type, new_structured_type;
non terminal structured_type, array_type, index_list, index_type, ordinal_type, component_type;
non terminal record_type, record_section_list, record_section, variant_part, variant_selector;
non terminal variant_list, variant, case_constant_list, case_constant, tag_field, tag_type;
non terminal set_type, base_type, file_type, new_pointer_type, domain_type, variable_declaration_part;
non terminal variable_declaration_list, variable_declaration, procedure_and_function_declaration_part;
non terminal proc_or_func_declaration_list, proc_or_func_declaration, procedure_declaration;
non terminal procedure_heading, directive;
non terminal List<Tipo> formal_parameter_list, formal_parameter_section_list;
non terminal List<Tipo> formal_parameter_section, value_parameter_specification, variable_parameter_specification;
non terminal procedural_parameter_specification, functional_parameter_specification;
non terminal String procedure_identification, function_identification, direction;
non terminal procedure_block, function_declaration, function_heading;
non terminal function_block, statement_part, compound_statement, statement_sequence, statement, open_statement;
non terminal closed_statement, non_labeled_closed_statement, non_labeled_open_statement, repeat_statement;
non terminal open_while_statement, closed_while_statement, open_for_statement, closed_for_statement;
non terminal open_with_statement, closed_with_statement, open_if_statement, closed_if_statement;
non terminal Tipo assignment_statement;
non terminal Exp variable_access; 
non terminal indexed_variable, index_expression_list, index_expression;
non terminal field_designator, procedure_statement;
non terminal List<Exp> params, actual_parameter_list;
non terminal Exp actual_parameter;
non terminal goto_statement, case_statement, case_index, case_list_element_list, case_list_element;
non terminal Exp control_variable, initial_value, final_value, record_variable_list;
non terminal Exp boolean_expression, expression, simple_expression, term, factor, exponentiation, primary;
non terminal Exp unsigned_constant, unsigned_number, unsigned_integer, unsigned_real, function_designator;
non terminal set_constructor, member_designator_list, member_designator, relop;
non terminal String identifier, addop, mulop, sign;
non terminal semicolon, comma;
                

program             ::= program_heading block DOT;
program_heading     ::= PROGRAM identifier LPAREN identifier_list RPAREN SEMICOLON;
block               ::= declaration_part statement_part;
declaration_part    ::= label;
statement_part      ::= begin statement_sequence end;
statement_sequence  ::= ;

identifier          ::= letter {letter | digit};
identifier_list     ::= identifier {COLON identifier};
letter              ::= LETTER;
